package xyz.monology.spigotlin.dsl

import org.bukkit.enchantments.Enchantment
import org.bukkit.inventory.ItemStack
import xyz.monology.spigotlin.gui.GUI
import xyz.monology.spigotlin.gui.OnClickEvent

/**
 * This is the inner helper-object for GUI DSLs.
 */
class GUIDSL(val title: String, val rows: Byte) {
    val gui = GUI(title, rows)

    /**
     * This sets a corresponding [itemStack] to an [index] location on the [gui].
     */
    operator fun set(index: Int, itemStack: ItemStack) {
        gui.spigot.setItem(index + 1, itemStack)
    }

    /**
     * This sets a corresponding [item] to this [index] location on the [gui].
     */
    operator fun set(index: Int, item: Pair<ItemStack, OnClickEvent.() -> Unit>) {
        gui.spigot.setItem(index + 1, item.first)
        gui.onClick[index] = {
            if (index in gui.onClick) gui.onClick[index]
            item.second(this)
        }
    }

    fun ItemStack.onClick(block: OnClickEvent.() -> Unit) = Pair(this, block)

    /**
     * This adds [itemStack] to the next free slot in [gui].
     */
    fun add(itemStack: ItemStack) {
        gui.spigot.addItem(itemStack)
    }

    operator fun set(row: Int, column: Int, itemStack: ItemStack) {
        val index = (row - 1) * 9 + column - 1
        set(index, itemStack)
    }

    /**
     * This sets a corresponding [item] to this [row] and this [column].
     */
    operator fun set(row: Int, column: Int, item: Pair<ItemStack, OnClickEvent.() -> Unit>) {
        val index = (row - 1) * 9 + column - 1
        set(index, item.first)
        gui.onClick[index] = {
            if (index in gui.onClick) gui.onClick[index]?.invoke(this)
            item.second(this)
        }
    }

    /**
     * This fills the remaining slots in the [gui] with ItemStacks generated by [block].
     */
    inline fun fill(block: (Int) -> ItemStack) {
        var first: Int = gui.spigot.firstEmpty()
        while (first != -1) {
            gui.spigot.addItem(block(first + 1))
            first = gui.spigot.firstEmpty()
        }
    }

    /**
     * This fills the remaining slots in the [gui] with this [itemStack].
     */
    fun fill(itemStack: ItemStack) {
        fill { itemStack }
    }

    /**
     * This fills and replaces ItemStacks generated by [block] in this [range].
     */
    fun fill(range: IntRange, block: (Int) -> ItemStack) {
        range.forEach {
            gui.spigot.setItem(it, block(it + 1))
        }
    }

    /**
     * This fills and replace the indices of [range] with [itemStack].
     */
    fun fill(range: IntRange, itemStack: ItemStack) {
        fill(range) { itemStack }
    }

    /**
     * @see add
     */
    operator fun plusAssign(itemStack: ItemStack) {
        add(itemStack)
    }

    /**
     * @see add
     */
    operator fun ItemStack.unaryPlus() {
        add(this)
    }

    infix fun Pair<Enchantment, Int>.to(third: Boolean): Triple<Enchantment, Int, Boolean> {
        return Triple(first, second, third)
    }
}

/**
 * This creates an IntRange starting on this [row], going [from] column [to] column. If the columns exceed the maximum value (8), it will jump to the next row.
 */
fun simpleRowIntRange(row: Int, from: Int, to: Int): IntRange {
    return ((row - 1) * 9).run {
        IntRange(this + from - 1, this + to - 1)
    }}

/**
 * This initializes a GUI DSL.
 */
inline fun gui(title: String, rows: Byte, block: GUIDSL.() -> Unit): GUI {
    return GUIDSL(title, rows).apply(block).gui
}